//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include "BatchMeshGeneratorAction.h"
#include "ActionFactory.h"

#include "MooseMesh.h"
#include "MeshGenerator.h"
#include "Factory.h"
#include "MooseApp.h"

#include "hit/hit.h"

registerMooseAction("MooseApp", BatchMeshGeneratorAction, "add_mesh_generator");

InputParameters
BatchMeshGeneratorAction::validParams()
{
  InputParameters params = Action::validParams();

  params.set<std::string>("type") = "BatchMeshGeneratorAction";

  params.addClassDescription("Batch generate meshes using actions.");
  params.addRequiredParam<std::string>("mesh_generator_name",
                                       "Names of the mesh generator to be batch generated.");
  params.addRequiredParam<std::string>("mesh_name_prefix",
                                       "Prefix name of the meshes to be batch generated.");

  params.addParam<std::vector<std::string>>("batch_scalar_input_param_names",
                                            std::vector<std::string>(),
                                            "Names of the scalar input parameters to be altered.");
  MultiMooseEnum default_types("BOOL REAL SHORT USHORT INT UINT STRING ENUM", "");
  params.addParam<MultiMooseEnum>(
      "batch_scalar_input_param_types",
      default_types,
      "Types of the scalar input parameters to be altered in each generator of the batch.");
  params.addParam<std::vector<std::vector<std::string>>>(
      "batch_scalar_input_params", {}, "Values of the scalar input parameters to be assigned.");

  params.addParam<std::vector<std::string>>("batch_vector_input_param_names",
                                            std::vector<std::string>(),
                                            "Name of the vector input parameters to be altered.");
  params.addParam<MultiMooseEnum>("batch_vector_input_param_types",
                                  default_types,
                                  "Type of the vector input parameters to be altered.");
  params.addParam<std::vector<std::vector<std::vector<std::string>>>>(
      "batch_vector_input_params", {}, "Values of the vector input parameters to be assigned.");

  MooseEnum multi_batch_params_method("corresponding cartesian_product", "cartesian_product");
  params.addParam<MooseEnum>("multi_batch_params_method",
                             multi_batch_params_method,
                             "Method to generate multiple batch parameters.Options: " +
                                 multi_batch_params_method.getRawNames());

  params.addParam<std::vector<std::string>>(
      "fixed_scalar_input_param_names", {}, "Names of the input parameters to be fixed.");
  params.addParam<MultiMooseEnum>("fixed_scalar_input_param_types",
                                  default_types,
                                  "Types of the input parameters to be fixed.");
  params.addParam<std::vector<std::string>>(
      "fixed_scalar_input_param_values", {}, "Values of the input parameters to be fixed.");
  params.addParam<std::vector<std::string>>(
      "fixed_vector_input_param_names", {}, "Names of the input vector parameters to be fixed.");
  params.addParam<MultiMooseEnum>("fixed_vector_input_param_types",
                                  default_types,
                                  "Types of the input vector parameters to be fixed.");
  params.addParam<std::vector<std::vector<std::string>>>(
      "fixed_vector_input_param_values", {}, "Values of the input vector parameters to be fixed.");
  params.addParam<bool>("use_decomposed_index",
                        false,
                        "Whether to use the decomposed index for the mesh name (only effective for "
                        "the cartesian_product method).");

  params.addParamNamesToGroup(
      "batch_scalar_input_param_names batch_scalar_input_param_types batch_scalar_input_params "
      "batch_vector_input_param_names batch_vector_input_param_types batch_vector_input_params",
      "Batch Input");
  params.addParamNamesToGroup("fixed_scalar_input_param_names fixed_scalar_input_param_types "
                              "fixed_scalar_input_param_values "
                              "fixed_vector_input_param_names fixed_vector_input_param_types "
                              "fixed_vector_input_param_values",
                              "Fixed Input");

  return params;
}

BatchMeshGeneratorAction::BatchMeshGeneratorAction(const InputParameters & params)
  : Action(params),
    _mesh_generator_name(getParam<std::string>("mesh_generator_name")),
    _mesh_name_prefix(getParam<std::string>("mesh_name_prefix")),
    _batch_scalar_input_param_names(
        getParam<std::vector<std::string>>("batch_scalar_input_param_names")),
    _batch_scalar_input_param_types(isParamValid("batch_scalar_input_param_types")
                                        ? getParam<MultiMooseEnum>("batch_scalar_input_param_types")
                                              .template getSetValueIDs<ParameterType>()
                                        : std::vector<ParameterType>()),
    _batch_scalar_input_params(
        getParam<std::vector<std::vector<std::string>>>("batch_scalar_input_params")),
    _batch_vector_input_param_names(
        getParam<std::vector<std::string>>("batch_vector_input_param_names")),
    _batch_vector_input_param_types(isParamValid("batch_vector_input_param_types")
                                        ? getParam<MultiMooseEnum>("batch_vector_input_param_types")
                                              .template getSetValueIDs<ParameterType>()
                                        : std::vector<ParameterType>()),
    _batch_vector_input_params(
        getParam<std::vector<std::vector<std::vector<std::string>>>>("batch_vector_input_params")),
    _multi_batch_params_method(getParam<MooseEnum>("multi_batch_params_method")
                                   .template getEnum<MultiBatchParamsMethod>()),
    _fixed_scalar_input_param_names(
        getParam<std::vector<std::string>>("fixed_scalar_input_param_names")),
    _fixed_scalar_input_param_types(isParamValid("fixed_scalar_input_param_types")
                                        ? getParam<MultiMooseEnum>("fixed_scalar_input_param_types")
                                              .template getSetValueIDs<ParameterType>()
                                        : std::vector<ParameterType>()),
    _fixed_scalar_input_param_values(
        getParam<std::vector<std::string>>("fixed_scalar_input_param_values")),
    _fixed_vector_input_param_names(
        getParam<std::vector<std::string>>("fixed_vector_input_param_names")),
    _fixed_vector_input_param_types(isParamValid("fixed_vector_input_param_types")
                                        ? getParam<MultiMooseEnum>("fixed_vector_input_param_types")
                                              .template getSetValueIDs<ParameterType>()
                                        : std::vector<ParameterType>()),
    _fixed_vector_input_param_values(
        getParam<std::vector<std::vector<std::string>>>("fixed_vector_input_param_values")),
    _use_decomposed_index(getParam<bool>("use_decomposed_index"))
{
  if (_fixed_scalar_input_param_names.size() != _fixed_scalar_input_param_types.size() ||
      _fixed_scalar_input_param_names.size() != _fixed_scalar_input_param_values.size())
  {
    mooseError("BatchMeshGeneratorAction: fixed_scalar_input_param_names, "
               "fixed_scalar_input_param_types, and "
               "fixed_scalar_input_param_values must have the same size.");
  }

  // Sanity check for the batch input parameters
  if (_batch_scalar_input_param_names.size() != _batch_scalar_input_param_types.size() ||
      _batch_scalar_input_param_names.size() != _batch_scalar_input_params.size())
  {
    mooseError("BatchMeshGeneratorAction: batch_scalar_input_param_names, "
               "batch_scalar_input_param_types, and "
               "batch_scalar_input_params must have the same size.");
  }
  if (_batch_vector_input_param_names.size() != _batch_vector_input_param_types.size() ||
      _batch_vector_input_param_names.size() != _batch_vector_input_params.size())
  {
    mooseError("BatchMeshGeneratorAction: batch_vector_input_param_names, "
               "batch_vector_input_param_types, and "
               "batch_vector_input_params must have the same size.");
  }
  // If the corresponding method is used, the number of batch parameters must be the same
  std::set<unsigned int> batch_params_sizes;
  if (_multi_batch_params_method == MultiBatchParamsMethod::corresponding)
  {
    for (const auto & unit_batch_scalar_params : _batch_scalar_input_params)
    {
      batch_params_sizes.emplace(unit_batch_scalar_params.size());
    }
    for (const auto & unit_batch_vector_params : _batch_vector_input_params)
    {
      batch_params_sizes.emplace(unit_batch_vector_params.size());
    }
    // The parameters should not be empty
    if (batch_params_sizes.empty())
    {
      mooseError("BatchMeshGeneratorAction: batch_scalar_input_params and "
                 "batch_vector_input_params cannot be empty.");
    }
    else if (batch_params_sizes.size() > 1)
    {
      mooseError("BatchMeshGeneratorAction: batch_scalar_input_params and "
                 "batch_vector_input_params must have the same size.");
    }
  }
}

void
BatchMeshGeneratorAction::act()
{
  if (_current_task == "add_mesh_generator")
    addMeshGenerators();
}

void
BatchMeshGeneratorAction::addMeshGenerators()
{
  std::vector<std::vector<std::string>> processed_batch_scalar_input_params;
  std::vector<std::vector<std::vector<std::string>>> processed_batch_vector_input_params;
  // generate the decomposed indices for the cartesian product method
  std::vector<std::vector<unsigned int>> processed_batch_indices;
  if (_multi_batch_params_method == MultiBatchParamsMethod::corresponding)
  {
    processed_batch_scalar_input_params = _batch_scalar_input_params;
    processed_batch_vector_input_params = _batch_vector_input_params;
    if (_use_decomposed_index)
    {
      processed_batch_indices.push_back(
          std::vector<unsigned int>(processed_batch_vector_input_params.empty()
                                        ? processed_batch_scalar_input_params.front().size()
                                        : processed_batch_vector_input_params.front().size()));
      std::iota(processed_batch_indices.back().begin(), processed_batch_indices.back().end(), 0);
    }
  }
  else // cartesian_product
  {
    // We basically need to reconstruct the corresponding parameters based on the cartesian product
    // algorithm
    for (const auto i : index_range(_batch_scalar_input_params))
    {
      // For the first element, just copy the parameters
      if (processed_batch_scalar_input_params.empty())
      {
        processed_batch_scalar_input_params.push_back(_batch_scalar_input_params[i]);
        if (_use_decomposed_index)
        {
          processed_batch_indices.push_back(
              std::vector<unsigned int>(_batch_scalar_input_params[i].size()));
          std::iota(
              processed_batch_indices.back().begin(), processed_batch_indices.back().end(), 0);
        }
      }
      else
      {
        const unsigned int num_new_batch_params = _batch_scalar_input_params[i].size();
        const unsigned int num_processed_batch_params =
            processed_batch_scalar_input_params.front().size();
        // All the elements in the processed_batch_scalar_input_params need to be duplicated for
        // num_new_batch_params times
        for (auto & unit_processed_batch_scalar_input_params : processed_batch_scalar_input_params)
        {
          auto temp_params = unit_processed_batch_scalar_input_params;
          for (unsigned int j = 1; j < num_new_batch_params; j++)
          {
            unit_processed_batch_scalar_input_params.insert(
                unit_processed_batch_scalar_input_params.end(),
                temp_params.begin(),
                temp_params.end());
          }
        }
        if (_use_decomposed_index)
        {
          // Same as the composed indices
          for (auto & unit_processed_batch_indices : processed_batch_indices)
          {
            auto temp_indices = unit_processed_batch_indices;
            for (unsigned int j = 1; j < num_new_batch_params; j++)
            {
              unit_processed_batch_indices.insert(
                  unit_processed_batch_indices.end(), temp_indices.begin(), temp_indices.end());
            }
          }
        }

        // Then, add a new element to the processed_batch_scalar_input_params by repeating each
        // element in _batch_scalar_input_params[i] for num_processed_batch_params times
        processed_batch_scalar_input_params.push_back({});
        for (const auto & unit_batch_scalar_input_params : _batch_scalar_input_params[i])
          for (unsigned int j = 0; j < num_processed_batch_params; j++)
            processed_batch_scalar_input_params.back().push_back(unit_batch_scalar_input_params);
        if (_use_decomposed_index)
        {
          // Same as the composed indices
          processed_batch_indices.push_back({});
          for (const auto & unit_batch_scalar_input_params_index :
               index_range(_batch_scalar_input_params[i]))
            for (unsigned int j = 0; j < num_processed_batch_params; j++)
              processed_batch_indices.back().push_back(unit_batch_scalar_input_params_index);
        }
      }
    }
    for (const auto i : index_range(_batch_vector_input_params))
    {
      // For the first element, just copy the parameters
      if (processed_batch_vector_input_params.empty())
        if (processed_batch_scalar_input_params.empty())
        {
          // if no batch scalar input parameters are used
          // we just need to initiate the processed_batch_vector_input_params as the first one to
          // fill
          processed_batch_vector_input_params.push_back(_batch_vector_input_params[i]);
          if (_use_decomposed_index)
          {
            processed_batch_indices.push_back(
                std::vector<unsigned int>(_batch_vector_input_params[i].size()));
            std::iota(
                processed_batch_indices.back().begin(), processed_batch_indices.back().end(), 0);
          }
        }
        else
        {
          processed_batch_vector_input_params.push_back({});
          // if there are batch scalar input parameters, then each element needs to be duplicated
          // for that amount of times
          for (const auto & unit_batch_vector_input_params : _batch_vector_input_params[i])
            for (unsigned int j = 0; j < processed_batch_scalar_input_params.front().size(); j++)
              processed_batch_vector_input_params.back().push_back(unit_batch_vector_input_params);
          // Then the scalar input parameters need to be duplicated for the number of elements in
          // the processed_batch_vector_input_params
          for (auto & unit_processed_batch_scalar_input_params :
               processed_batch_scalar_input_params)
          {
            auto temp_params = unit_processed_batch_scalar_input_params;
            for (unsigned int j = 1; j < processed_batch_vector_input_params.back().size(); j++)
            {
              unit_processed_batch_scalar_input_params.insert(
                  unit_processed_batch_scalar_input_params.end(),
                  temp_params.begin(),
                  temp_params.end());
            }
          }
          if (_use_decomposed_index)
          {
            // Add the indices for the first batch vector input parameter
            processed_batch_indices.push_back({});
            for (const auto & unit_batch_vector_input_params_index :
                 index_range(_batch_vector_input_params[i]))
              for (unsigned int j = 0; j < processed_batch_indices.front().size(); j++)
                processed_batch_indices.back().push_back(unit_batch_vector_input_params_index);
            // Duplicate the indices for the batch scalar input parameters
            for (unsigned int k = 1; k < processed_batch_indices.size(); k++)
            {
              auto & unit_processed_batch_indices = processed_batch_indices[k - 1];
              auto temp_indices = unit_processed_batch_indices;
              for (unsigned int j = 1; j < _batch_vector_input_params[i].size(); j++)
              {
                unit_processed_batch_indices.insert(
                    unit_processed_batch_indices.end(), temp_indices.begin(), temp_indices.end());
              }
            }
          }
        }
      else
      {
        const unsigned int num_new_batch_params = _batch_vector_input_params[i].size();
        const unsigned int num_processed_batch_params =
            processed_batch_vector_input_params.front().size();
        // All the elements in the processed_batch_vector_input_params need to be duplicated for
        // num_new_batch_params times
        for (auto & unit_processed_batch_vector_input_params : processed_batch_vector_input_params)
        {
          auto temp_params = unit_processed_batch_vector_input_params;
          for (unsigned int j = 1; j < num_new_batch_params; j++)
          {
            unit_processed_batch_vector_input_params.insert(
                unit_processed_batch_vector_input_params.end(),
                temp_params.begin(),
                temp_params.end());
          }
        }
        if (_use_decomposed_index)
        {
          // Same for the decomposed indices
          for (auto & unit_processed_batch_indices : processed_batch_indices)
          {
            auto temp_indices = unit_processed_batch_indices;
            for (unsigned int j = 1; j < num_new_batch_params; j++)
            {
              unit_processed_batch_indices.insert(
                  unit_processed_batch_indices.end(), temp_indices.begin(), temp_indices.end());
            }
          }
        }
        // if there are also batch scalar input parameters, it also needs to be duplicated
        for (auto & unit_processed_batch_scalar_input_params : processed_batch_scalar_input_params)
        {
          auto temp_params = unit_processed_batch_scalar_input_params;
          for (unsigned int j = 1; j < num_new_batch_params; j++)
          {
            unit_processed_batch_scalar_input_params.insert(
                unit_processed_batch_scalar_input_params.end(),
                temp_params.begin(),
                temp_params.end());
          }
        }
        // Then, add a new element to the processed_batch_vector_input_params by repeating each
        // element in _batch_vector_input_params[i] for num_processed_batch_params times
        processed_batch_vector_input_params.push_back({});
        for (const auto & unit_batch_vector_input_params : _batch_vector_input_params[i])
          for (unsigned int j = 0; j < num_processed_batch_params; j++)
            processed_batch_vector_input_params.back().push_back(unit_batch_vector_input_params);
        if (_use_decomposed_index)
        {
          // Same for the decomposed indices
          processed_batch_indices.push_back({});
          for (const auto & unit_batch_vector_input_params_index :
               index_range(_batch_vector_input_params[i]))
            for (unsigned int j = 0; j < num_processed_batch_params; j++)
              processed_batch_indices.back().push_back(unit_batch_vector_input_params_index);
        }
      }
    }
  }

  // Now, we can add the mesh generators by looping through the processed params
  const unsigned int num_batch_params = processed_batch_vector_input_params.empty()
                                            ? processed_batch_scalar_input_params.front().size()
                                            : processed_batch_vector_input_params.front().size();
  for (const auto i : make_range(num_batch_params))
  {
    auto params = _app.getFactory().getValidParams(_mesh_generator_name);
    for (const auto j : index_range(_batch_scalar_input_params))
      setScalarParams(params,
                      _batch_scalar_input_param_names[j],
                      _batch_scalar_input_param_types[j],
                      processed_batch_scalar_input_params[j][i]);
    for (const auto j : index_range(_batch_vector_input_params))
      setVectorParams(params,
                      _batch_vector_input_param_names[j],
                      _batch_vector_input_param_types[j],
                      processed_batch_vector_input_params[j][i]);
    for (const auto j : index_range(_fixed_scalar_input_param_names))
      setScalarParams(params,
                      _fixed_scalar_input_param_names[j],
                      _fixed_scalar_input_param_types[j],
                      _fixed_scalar_input_param_values[j]);
    for (const auto j : index_range(_fixed_vector_input_param_names))
      setVectorParams(params,
                      _fixed_vector_input_param_names[j],
                      _fixed_vector_input_param_types[j],
                      _fixed_vector_input_param_values[j]);

    std::string mesh_index;
    if (_use_decomposed_index)
      for (const auto & process_batch_index : processed_batch_indices)
        mesh_index += '_' + std::to_string(process_batch_index[i]);
    else
      mesh_index = "_" + std::to_string(i);

    _app.getMeshGeneratorSystem().addMeshGenerator(
        _mesh_generator_name, _mesh_name_prefix + mesh_index, params);
  }
}

void
BatchMeshGeneratorAction::setScalarParams(InputParameters & params,
                                          const std::string & param_name,
                                          const ParameterType & param_type,
                                          const std::string & param_value)
{
  switch (param_type)
  {
    case (ParameterType::REAL):
      convertAndSetNumericScalar<Real>(params, param_name, param_value);
      break;
    case (ParameterType::SHORT):
      convertAndSetNumericScalar<short>(params, param_name, param_value);
      break;
    case (ParameterType::USHORT):
      convertAndSetNumericScalar<unsigned short>(params, param_name, param_value);
      break;
    case (ParameterType::INT):
      convertAndSetNumericScalar<int>(params, param_name, param_value);
      break;
    case (ParameterType::UINT):
      convertAndSetNumericScalar<unsigned int>(params, param_name, param_value);
      break;
    case (ParameterType::ENUM):
      if (params.isType<MooseEnum>(param_name))
        params.set<MooseEnum>(param_name) = param_value;
      break;
    case (ParameterType::STRING):
      if (params.isType<std::string>(param_name))
        params.set<std::string>(param_name) = param_value;
      break;
    case (ParameterType::BOOL):
      if (params.isType<bool>(param_name))
        hit::toBool(param_value, &params.set<bool>(param_name));
      break;
    default:
      mooseError("impossible situation."); // as we use MultiMooseEnum to ensure the type is valid
  }
}

void
BatchMeshGeneratorAction::setVectorParams(InputParameters & params,
                                          const std::string & param_name,
                                          const ParameterType & param_type,
                                          const std::vector<std::string> & param_value)
{
  switch (param_type)
  {
    case (ParameterType::REAL):
      convertAndSetNumericVector<Real>(params, param_name, param_value);
      break;
    case (ParameterType::SHORT):
      convertAndSetNumericVector<short>(params, param_name, param_value);
      break;
    case (ParameterType::USHORT):
      convertAndSetNumericVector<unsigned short>(params, param_name, param_value);
      break;
    case (ParameterType::INT):
      convertAndSetNumericVector<int>(params, param_name, param_value);
      break;
    case (ParameterType::UINT):
      convertAndSetNumericVector<unsigned int>(params, param_name, param_value);
      break;
    case (ParameterType::ENUM):
      if (params.isType<std::vector<MooseEnum>>(param_name))
        params.set<MultiMooseEnum>(param_name) = param_value;
      break;
    case (ParameterType::STRING):
      if (params.isType<std::vector<std::string>>(param_name))
        params.set<std::vector<std::string>>(param_name) = param_value;
      break;
    case (ParameterType::BOOL):
      if (params.isType<std::vector<bool>>(param_name))
      {
        std::vector<bool> values(param_value.size());
        std::transform(param_value.begin(),
                       param_value.end(),
                       values.begin(),
                       [](const std::string & val)
                       {
                         bool tmp;
                         hit::toBool(val, &tmp);
                         return tmp;
                       });
        params.set<std::vector<bool>>(param_name) = values;
      }
      break;
    default:
      mooseAssert(false,
                  "impossible situation."); // as we use MultiMooseEnum to ensure the type is valid
  }
}

template <typename T>
void
BatchMeshGeneratorAction::convertAndSetNumericScalar(InputParameters & params,
                                                     const std::string & param_name,
                                                     const std::string & param_value)
{
  if (params.isType<T>(param_name))
    params.set<T>(param_name) = MooseUtils::convert<T>(param_value);
}

template <typename T>
void
BatchMeshGeneratorAction::convertAndSetNumericVector(InputParameters & params,
                                                     const std::string & param_name,
                                                     const std::vector<std::string> & param_value)
{
  std::vector<T> values(param_value.size());
  std::transform(param_value.begin(),
                 param_value.end(),
                 values.begin(),
                 [](const std::string & val) { return MooseUtils::convert<T>(val); });
  if (params.isType<std::vector<T>>(param_name))
    params.set<std::vector<T>>(param_name) = values;
}
